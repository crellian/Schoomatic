#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

"""
CARLA Dynamic Weather:

Connect to a CARLA Simulator instance and control the weather. Change Sun
position smoothly with time and generate storms occasionally.
"""

import glob
import os
import sys
import time
import yaml
import random
from PIL import Image
import numpy as np

from carla_birdeye_view import BirdViewProducer, BirdViewCropType, PixelDimensions

try:
    sys.path.append(glob.glob('/opt/carla-simulator/PythonAPI/carla/dist/carla-0.9.13-py3.7-linux-x86_64.egg')[0])
except IndexError:
    pass

import carla
from spawn_npc import NPCClass

import argparse


def clamp(value, minimum=0.0, maximum=100.0):
    return max(minimum, min(value, maximum))


class Weather(object):
    def __init__(self, weather, config):
        self.weather = weather
        self.config = config

    def tick(self):
        self.weather.cloudiness = random.uniform(self.config['cloudiness']['min'], self.config['cloudiness']['max'])
        self.weather.precipitation = random.uniform(self.config['precipitation']['min'], self.config['precipitation']['max'])
        self.weather.precipitation_deposits = random.uniform(self.config['precipitation_deposits']['min'], self.config['precipitation_deposits']['max'])
        self.weather.wind_intensity = random.uniform(self.config['wind_intensity']['min'], self.config['wind_intensity']['max'])
        self.weather.fog_density = random.uniform(self.config['fog_density']['min'], self.config['fog_density']['max'])
        self.weather.wetness = random.uniform(self.config['wetness']['min'], self.config['wetness']['max'])
        self.weather.fog_distance = random.uniform(self.config['fog_distance']['min'], self.config['fog_distance']['max'])
        self.weather.fog_falloff = random.uniform(self.config['fog_falloff']['min'], self.config['fog_falloff']['max'])
        self.weather.scattering_intensity = random.uniform(self.config['scattering_intensity']['min'], self.config['scattering_intensity']['max'])
        self.weather.mie_scattering_scale = random.uniform(self.config['mie_scattering_scale']['min'], self.config['mie_scattering_scale']['max'])
        self.weather.rayleigh_scattering_scale = random.uniform(self.config['rayleigh_scattering_scale']['min'], self.config['rayleigh_scattering_scale']['max'])
        self.weather.dust_storm = random.uniform(self.config['dust_storm']['min'], self.config['dust_storm']['max'])
        self.weather.sun_azimuth_angle = random.uniform(self.config['sun_azimuth_angle']['min'], self.config['sun_azimuth_angle']['max'])
        self.weather.sun_altitude_angle = random.uniform(self.config['sun_altitude_angle']['min'], self.config['sun_altitude_angle']['max'])


def save_image(image, path, weather, agent, bp, townn):
    birdview = bp.produce(
        agent_vehicle=agent  # carla.Actor (spawned vehicle)
    )

    rgb = birdview[:,:,0]*255
    im = Image.fromarray(rgb)
    im = im.save(os.path.join(path, townn+'_bev_%.6d.jpg' % image.frame))

    global cnt
    cnt += 1
    image.save_to_disk(os.path.join(path, townn+'_%.6d.jpg' % image.frame))

    print('No.'+str(cnt)+'  %.6d.jpg:  ' % image.frame + str(weather)[18:] + "\n")

    global lock
    lock = False



def spawn(world, spawn_points, vehicle_blueprint, path, townn, res, bp):
    vehicle = None
    while not vehicle:
        random.shuffle(spawn_points)
        spawn_point = spawn_points[0]
        spawn_point.location.z += 0.1
        vehicle = world.try_spawn_actor(vehicle_blueprint, spawn_point)

    # spawn a rgb sensor attached to the car
    rgb_sensor = world.get_blueprint_library().find('sensor.camera.rgb')
    # Modify the attributes of the blueprint to set image resolution and field of view.
    rgb_sensor.set_attribute('image_size_x', str(res[0]))
    rgb_sensor.set_attribute('image_size_y', str(res[1]))
    rgb_sensor.set_attribute('fov', '80')
    # Set the time in seconds between sensor captures
    rgb_sensor.set_attribute('sensor_tick', '0.01')
    # Provide the position of the sensor relative to the vehicle.
    transform = carla.Transform(carla.Location(x=0.8, z=2.5))
    # Tell the world to spawn the sensor, don't forget to attach it to your vehicle actor.
    sensor01 = world.spawn_actor(rgb_sensor, transform, attach_to=vehicle)
    # Subscribe to the sensor stream by providing a callback function, this function is
    # called each time a new image is generated by the sensor.
    sensor01.listen(lambda image: save_image(image, path, world.get_weather(), vehicle, bp, townn))

    return vehicle, sensor01


def main():
    argparser = argparse.ArgumentParser(
        description=__doc__)
    argparser.add_argument(
        '--host',
        metavar='H',
        default="192.168.0.183",
        help='IP of the host server (default: 127.0.0.1)')
    argparser.add_argument(
        '-p', '--port',
        metavar='P',
        default=2342,
        type=int,
        help='TCP port to listen to (default: 2000)')
    argparser.add_argument(
        '-m', '--map',
        metavar='M',
        default='Town10HD',
        type=str,
        help='Map for use (default: Town10HD)')
    argparser.add_argument(
        '-W', '--Width',
        metavar='W',
        default=480,
        type=int,
        help='Width of captured image (default: 640)')
    argparser.add_argument(
        '-H', '--Height',
        metavar='H',
        default=480,
        type=int,
        help='Height of captured image  (default: 480)')
    argparser.add_argument(
        '-f', '--file',
        metavar='F',
        default='/home2/fpv_bev1/',
        type=str,
        help='Path to store data (default: \'./data_collection/output\')')
    argparser.add_argument(
        '-n', '--num',
        metavar='N',
        default='200',
        type=int,
        help='Number of images to generate (default: 10000)')
    argparser.add_argument(
        '-r', '--random',
        metavar='R',
        default=True,
        type=bool,
        help='random (if True) or preset (if False) spawn points (default: True)')

    args = argparser.parse_args()

    with open('./config.yaml', 'r') as file:
        config = yaml.safe_load(file)

    global cnt
    cnt = 0
    client = carla.Client(args.host, args.port)
    client.set_timeout(200.0)
    world = client.load_world(args.map)

    birdview_producer = BirdViewProducer(
        client,  # carla.Client
        target_size=PixelDimensions(width=64, height=64),
        pixels_per_meter=2,
        crop_type=BirdViewCropType.FRONT_AREA_ONLY,
        render_lanes_on_junctions=False
    )

    #npc = NPCClass(client)
    #npc.create_npcs(config['nvehicles'], config['npeople'])

    weather = Weather(world.get_weather(), config)

    vehicle_blueprint = world.get_blueprint_library().filter('model3')[0]

    # retrieve spawn points
    if args.random:
        im = Image.open('./Town/'+args.map+'.jpg')
        data = np.array(im)
        red, green, blue = data.T
        condition = (red == 255) & (green == 255) & (blue == 255)
        white_area = condition.nonzero()
        number_of_spawn_points = len(white_area[0])

        ps = np.load('./Town/'+args.map+'.npy')
        min_x = min(ps[:, 0])
        min_y = min(ps[:, 1])

        spawn_points = []
        for i in range(number_of_spawn_points):
            waypoint01 = world.get_map().get_waypoint(carla.Location(x=white_area[0][i]+min_x, y=white_area[1][i]+min_y, z=0),
                                          project_to_road=True,
                                          lane_type=carla.LaneType.Driving)
            z = 2.5
            spawn_points.append(carla.Transform(
                carla.Location(x=white_area[0][i]+min_x, y=white_area[1][i]+min_y, z=z),
                carla.Rotation(yaw=random.uniform(0, 360))))
    else:
        waypoints = world.get_map().generate_waypoints(distance=1.0)
        number_of_spawn_points = len(waypoints)

        spawn_points = []
        for i in range(number_of_spawn_points):
            spawn_points.append(waypoints[i].transform)

    if number_of_spawn_points > 0:
        global lock
        while True:
            if cnt >= args.num:
                break
            lock = True

            # change weather
            weather.tick()
            world.set_weather(weather.weather)

            # spawn a car at random spot
            vehicle, sensor01 = spawn(world, spawn_points, vehicle_blueprint, args.file, args.map, (args.Width, args.Height), birdview_producer)

            while lock:
                continue

            # destroy
            sensor01.destroy()
            vehicle.destroy()
    else:
        print('Could not found any spawn points')

if __name__ == '__main__':

    main()
